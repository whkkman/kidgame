<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Emoji åŠå®¢å†’éšª v15 - æœ€çµ‚å„ªåŒ–ç‰ˆ</title>
    <style>
        body {
            margin: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #222;
            color: white;
            font-family: 'Microsoft JhengHei', 'Segoe UI', sans-serif;
            overflow: hidden;
            touch-action: none;
        }
        #gameContainer {
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            max-width: 100%; 
            max-height: 100vh;
        }
        canvas {
            background-color: #87CEEB; /* å¤©ç©ºè— */
            border-radius: 4px;
            display: block;
            max-width: 100%;
            height: auto;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 20px;
            font-weight: bold;
            color: #333;
            background: rgba(255, 255, 255, 0.7);
            padding: 5px 10px;
            border-radius: 5px;
            pointer-events: none;
        }
        #levelInfo {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 20px;
            font-weight: bold;
            color: white;
            background: #444;
            padding: 5px 10px;
            border-radius: 5px;
            pointer-events: none;
        }
        #instructions {
            margin-top: 10px;
            text-align: center;
            color: #aaa;
            font-size: 14px;
            padding: 0 10px;
        }
        
        /* --- ä¿®æ”¹ï¼šé‡æ–°é–‹å§‹æŒ‰éˆ•ä½ç½® (ç•«é¢ä¸‹æ–¹ä¸­é–“) --- */
        #restartBtn {
            position: absolute;
            bottom: 80px; /* è·é›¢åº•éƒ¨ 80pxï¼Œé¿å…è·Ÿè§¸æ§æŒ‰éˆ•é‡ç–Š(å¦‚æœæœ‰) */
            left: 50%;
            transform: translateX(-50%); /* æ°´å¹³ç½®ä¸­ */
            padding: 15px 40px;
            font-size: 24px;
            font-weight: bold;
            color: white;
            background-color: #4CAF50;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            display: none;
            font-family: 'Microsoft JhengHei', sans-serif;
            box-shadow: 0 5px #2E7D32;
            transition: all 0.1s;
            z-index: 100;
        }
        #restartBtn:hover { background-color: #45a049; }
        #restartBtn:active {
            box-shadow: 0 2px #2E7D32;
            transform: translate(-50%, 2px);
        }

        /* è§¸æ§æŒ‰éˆ• */
        #touchControls {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 30px;
            box-sizing: border-box;
            pointer-events: none;
            z-index: 50;
        }
        .control-group {
            display: flex;
            gap: 20px;
            pointer-events: auto;
        }
        .touch-btn {
            width: 65px;
            height: 65px;
            background: rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 35px;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
            cursor: pointer;
            backdrop-filter: blur(2px);
            border: 2px solid rgba(255,255,255,0.2);
        }
        .touch-btn:active {
            background: rgba(255, 255, 255, 0.7);
            transform: scale(0.95);
        }
    </style>
</head>
<body>

    <div id="gameWrapper">
        <div id="gameContainer">
            <canvas id="gameCanvas" width="800" height="400"></canvas>
            <div id="ui">HP: â¤ï¸â¤ï¸â¤ï¸â¤ï¸â¤ï¸</div>
            <div id="levelInfo">ç¬¬ 1 é—œ</div>
            <button id="restartBtn">ğŸ® é‡æ–°é–‹å§‹</button>

            <div id="touchControls">
                <div class="control-group">
                    <div class="touch-btn" id="btnLeft">â¬…ï¸</div>
                    <div class="touch-btn" id="btnRight">â¡ï¸</div>
                </div>
                <div class="control-group">
                    <div class="touch-btn" id="btnJump">ğŸ¦˜</div>
                    <div class="touch-btn" id="btnAttack" style="font-size: 30px;">âš”ï¸</div>
                </div>
            </div>

        </div>
        <div id="instructions">
            é›»è…¦ï¼šâ¬…ï¸â¡ï¸ç§»å‹• | ç©ºç™½éµè·³èº | Zæ”»æ“Š<br>
            æ‰‹æ©Ÿï¼šä½¿ç”¨è¢å¹•æŒ‰éˆ•éŠç©
        </div>
    </div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const ui = document.getElementById('ui');
    const levelInfo = document.getElementById('levelInfo');
    const restartBtn = document.getElementById('restartBtn');

    // --- ç‰©ç†åƒæ•¸ ---
    const GRAVITY = 0.25;      
    const JUMP_STRENGTH = -10; 
    const ACCELERATION = 0.5; 
    const FRICTION = 0.9;     
    const MAX_SPEED = 8;      
    const ATTACK_DURATION = 40; 
    const LOGICAL_CANVAS_WIDTH = 800; 

    // --- éŠæˆ²ç‹€æ…‹è®Šæ•¸ ---
    let currentLevel = 1;
    let cameraX = 0;
    let particles = []; 
    let isGameWon = false;
    let isLevelSwitching = false;
    let isDead = false;

    // æŒ‰éµç‹€æ…‹
    const keys = { ArrowRight: false, ArrowLeft: false, Space: false };

    // --- è§’è‰² ---
    const player = {
        x: 50,
        y: 100,
        width: 40,
        height: 40,
        vx: 0,
        vy: 0,
        hp: 5,
        maxHp: 5,
        grounded: false,
        facingRight: true,
        attacking: false,
        attackTimer: 0,
        invulnerable: 0,
        emoji: 'ğŸ¤º'
    };

    let platforms = [];
    let enemies = [];
    let foods = [];
    let exitDoor = {};
    let worldWidth = 0;

    function resetInput() {
        keys.ArrowRight = false;
        keys.ArrowLeft = false;
        keys.Space = false;
        player.vx = 0;
        player.vy = 0;
    }

    // ==========================================
    //              é—œå¡è¨­è¨ˆ
    // ==========================================
    function setupLevel(level) {
        resetInput();
        
        isLevelSwitching = false;
        isDead = false;
        isGameWon = false;
        restartBtn.style.display = 'none'; 

        player.x = 50;
        player.y = 100;
        cameraX = 0;

        levelInfo.innerText = `ç¬¬ ${level} é—œ`;

        if (level === 1) {
            worldWidth = 1600;
            platforms = [
                { x: 0, y: 350, w: 1600, h: 50 }, 
                { x: 400, y: 280, w: 100, h: 70 }, 
                { x: 500, y: 210, w: 100, h: 140 },
                { x: 900, y: 250, w: 200, h: 20 },
            ];
            enemies = [
                { x: 600, y: 200, w: 40, h: 40, vx: 2, vy: 0, hp: 1, maxHp: 1, type: 'ğŸ‘¾' },
                { x: 1000, y: 200, w: 40, h: 40, vx: 2, vy: 0, hp: 1, maxHp: 1, type: 'ğŸ‘¾' },
                { x: 1200, y: 300, w: 40, h: 40, vx: 3, vy: 0, hp: 1, maxHp: 1, type: 'ğŸ' }
            ];
            foods = [{ x: 950, y: 210, w: 30, h: 30, eaten: false, type: 'ğŸ–' }];
            exitDoor = { x: 1450, y: 270, w: 60, h: 80, emoji: 'ğŸšª' };

        } else if (level === 2) {
            worldWidth = 2200;
            platforms = [
                { x: 0, y: 350, w: 600, h: 50 },
                { x: 700, y: 300, w: 150, h: 20 }, 
                { x: 950, y: 250, w: 150, h: 20 },
                { x: 1200, y: 350, w: 1000, h: 50 }, 
                { x: 1600, y: 250, w: 100, h: 20 }  
            ];
            enemies = [
                { x: 800, y: 50, w: 40, h: 40, vx: 0, vy: 0, hp: 2, maxHp: 2, type: 'ğŸ‘»', flying: true },
                { x: 1000, y: 50, w: 40, h: 40, vx: 0, vy: 0, hp: 2, maxHp: 2, type: 'ğŸ‘»', flying: true },
                { x: 1300, y: 300, w: 40, h: 40, vx: 1, vy: 0, hp: 3, maxHp: 3, type: 'ğŸ§Ÿ' }, 
                { x: 1800, y: 200, w: 60, h: 60, vx: 0, vy: 0, hp: 5, maxHp: 5, type: 'ğŸ‘¹', isBoss: true, name: "ä¾†æ‰“æˆ‘å‘€" }
            ];
            foods = [{ x: 1630, y: 210, w: 30, h: 30, eaten: false, type: 'ğŸ–' }];
            exitDoor = { x: 2050, y: 270, w: 60, h: 80, emoji: 'ğŸšª' };

        } else if (level === 3) {
            worldWidth = 3000;
            platforms = [
                { x: 0, y: 350, w: 500, h: 50 },
                { x: 600, y: 280, w: 100, h: 20 },
                { x: 800, y: 220, w: 100, h: 20 },
                { x: 1000, y: 160, w: 100, h: 20 },
                { x: 1200, y: 300, w: 100, h: 20 }, 
                { x: 1400, y: 350, w: 1600, h: 50 }, 
                { x: 2000, y: 250, w: 50, h: 100 }, 
            ];
            enemies = [];
            for(let i=0; i<4; i++) {
                enemies.push({ x: 600 + i*250, y: 50, w: 40, h: 40, vx: 0, vy: 0, hp: 2, maxHp: 2, type: 'ğŸ‘»', flying: true });
            }
            enemies.push({ x: 1500, y: 300, w: 40, h: 40, vx: 2, vy: 0, hp: 3, maxHp: 3, type: 'ğŸ§Ÿ' });
            enemies.push({ x: 1700, y: 300, w: 40, h: 40, vx: 4, vy: 0, hp: 1, maxHp: 1, type: 'ğŸ' });
            enemies.push({ x: 2600, y: 200, w: 100, h: 100, vx: 0, vy: 0, hp: 10, maxHp: 10, type: 'ğŸ‘¹', isBoss: true, name: "èŒƒé˜¿å‘†" });

            foods = [
                { x: 1030, y: 120, w: 30, h: 30, eaten: false, type: 'ğŸ–' },
                { x: 1900, y: 310, w: 30, h: 30, eaten: false, type: 'ğŸ–' }
            ];
            exitDoor = { x: 2900, y: 270, w: 60, h: 80, emoji: 'ğŸšª' };
        }
        enemies.forEach(e => e.hurtTimer = 0);
    }

    // ==========================================
    //              è¼¸å…¥æ§åˆ¶ (éµç›¤ + è§¸æ§)
    // ==========================================

    window.addEventListener('keydown', (e) => {
        if(e.code === 'Space') keys.Space = true;
        if(e.code === 'ArrowRight') keys.ArrowRight = true;
        if(e.code === 'ArrowLeft') keys.ArrowLeft = true;
        if(e.code === 'KeyZ') { if (!player.attacking) startAttack(); }
    });
    window.addEventListener('keyup', (e) => {
        if(e.code === 'Space') keys.Space = false;
        if(e.code === 'ArrowRight') keys.ArrowRight = false;
        if(e.code === 'ArrowLeft') keys.ArrowLeft = false;
    });

    function bindTouchControl(elementId, keyName, isAttack = false) {
        const elem = document.getElementById(elementId);
        
        elem.addEventListener('touchstart', (e) => {
            e.preventDefault(); 
            if (isAttack) {
                if (!player.attacking) startAttack();
            } else {
                keys[keyName] = true;
            }
        }, { passive: false });

        if (!isAttack) { 
            elem.addEventListener('touchend', (e) => {
                e.preventDefault();
                keys[keyName] = false;
            }, { passive: false });
        }
        
        elem.addEventListener('mousedown', (e) => {
             e.preventDefault();
             if (isAttack) { if (!player.attacking) startAttack(); } else { keys[keyName] = true; }
        });
        if (!isAttack) {
             elem.addEventListener('mouseup', (e) => { e.preventDefault(); keys[keyName] = false; });
        }
    }

    bindTouchControl('btnLeft', 'ArrowLeft');
    bindTouchControl('btnRight', 'ArrowRight');
    bindTouchControl('btnJump', 'Space');
    bindTouchControl('btnAttack', '', true); 

    restartBtn.addEventListener('click', () => {
        currentLevel = 1;
        player.hp = player.maxHp;
        particles = [];
        setupLevel(1);
        updateUI();
    });

    function startAttack() {
        player.attacking = true;
        player.attackTimer = ATTACK_DURATION;
    }

    function update() {
        if (isGameWon) {
            updateVictoryParticles();
            return;
        }

        if (player.hp <= 0) {
            if (isDead) return;
            isDead = true;
            setTimeout(() => {
                alert("ä½ å€’ä¸‹äº†... é‡æ–°æŒ‘æˆ°æœ¬é—œï¼");
                setupLevel(currentLevel);
                player.hp = 5;
                updateUI();
            }, 50);
            return;
        }

        // 1. ç©å®¶ç‰©ç†
        if (keys.ArrowRight) { player.vx += ACCELERATION; player.facingRight = true; }
        if (keys.ArrowLeft) { player.vx -= ACCELERATION; player.facingRight = false; }
        
        player.vx *= FRICTION;
        if (player.vx > MAX_SPEED) player.vx = MAX_SPEED;
        if (player.vx < -MAX_SPEED) player.vx = -MAX_SPEED;
        if (Math.abs(player.vx) < 0.1) player.vx = 0;

        player.x += player.vx;
        player.vy += GRAVITY;
        player.y += player.vy;
        
        if (keys.Space && player.grounded) {
            player.vy = JUMP_STRENGTH;
            player.grounded = false;
        }

        player.grounded = false; 
        platforms.forEach(p => checkPlatformCollision(player, p));

        // é‚Šç•Œ
        if (player.x < 0) { player.x = 0; player.vx = 0; }
        if (player.x + player.width > worldWidth) { player.x = worldWidth - player.width; player.vx = 0; }
        if (player.y > canvas.height + 200) {
            player.hp = 0; 
        }

        // 2. æ”å½±æ©Ÿ
        cameraX = player.x - LOGICAL_CANVAS_WIDTH / 2;
        if (cameraX < 0) cameraX = 0;
        if (cameraX > worldWidth - LOGICAL_CANVAS_WIDTH) cameraX = worldWidth - LOGICAL_CANVAS_WIDTH;

        // 3. æ”»æ“Š
        if (player.attacking) {
            player.attackTimer--;
            const attackRange = 80; 
            const hitX = player.facingRight ? player.x + player.width : player.x - attackRange;
            
            for (let i = enemies.length - 1; i >= 0; i--) {
                let enemy = enemies[i];
                if (enemy.hurtTimer > 0) continue;

                if (rectIntersect(hitX, player.y, attackRange, player.height, enemy.x, enemy.y, enemy.w, enemy.h)) {
                    enemy.hp--;
                    enemy.hurtTimer = 15;
                    let kX = enemy.isBoss ? 2 : 8;
                    let kY = enemy.isBoss ? -2 : -5;
                    enemy.vx = (enemy.x > player.x) ? kX : -kX;
                    enemy.vy = kY;

                    if (enemy.hp <= 0) enemies.splice(i, 1);
                }
            }
            if (player.attackTimer <= 0) player.attacking = false;
        }

        // 4. æ€ªç‰©é‚è¼¯
        enemies.forEach(enemy => {
            if (enemy.hurtTimer > 0) {
                enemy.hurtTimer--;
                enemy.vy += GRAVITY;
                enemy.vx *= 0.9;
            } else {
                if (enemy.flying) {
                    const dx = player.x - enemy.x;
                    const dy = player.y - enemy.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < 600) {
                        enemy.vx = (dx / dist) * 1.5;
                        enemy.vy = (dy / dist) * 1.5;
                    } else {
                        enemy.vx = 0; enemy.vy = 0;
                    }
                } else {
                    if (enemy.isBoss) {
                        if (Math.abs(player.x - enemy.x) < 500) {
                            let speed = 1.0;
                            enemy.vx = player.x > enemy.x ? speed : -speed;
                        } else {
                            enemy.vx = 0;
                        }
                    } else {
                        let speed = (enemy.type === 'ğŸ') ? 4 : (enemy.type === 'ğŸ§Ÿ' ? 0.5 : 2);
                        if (Math.abs(enemy.vx) < 0.1) enemy.vx = speed; 
                        if (enemy.vx > 0) enemy.vx = speed; else enemy.vx = -speed;
                    }
                    enemy.vy += GRAVITY;
                }
            }

            enemy.x += enemy.vx;
            enemy.y += enemy.vy;

            let enemyGrounded = false;
            if (!enemy.flying) {
                platforms.forEach(p => {
                    if (enemy.x + enemy.w > p.x && enemy.x < p.x + p.w &&
                        enemy.y + enemy.h > p.y && enemy.y + enemy.h < p.y + p.h + 10 &&
                        enemy.vy >= 0) {
                        enemy.y = p.y - enemy.h;
                        enemy.vy = 0;
                        enemyGrounded = true;
                    }
                });
            }

            if (!enemy.flying && enemyGrounded && enemy.hurtTimer === 0 && !enemy.isBoss) {
                let checkX = enemy.x + (enemy.vx > 0 ? enemy.w + 10 : -10);
                let groundAhead = false;
                platforms.forEach(p => {
                    if (checkX > p.x && checkX < p.x + p.w && Math.abs((enemy.y + enemy.h) - p.y) < 5) {
                        groundAhead = true;
                    }
                });
                if (!groundAhead || enemy.x <= 0 || enemy.x + enemy.w >= worldWidth) {
                    enemy.vx *= -1; 
                }
            }
            
            if (enemy.isBoss && enemy.y > canvas.height) { enemy.y = 200; enemy.vy = 0; }

            if (enemy.hurtTimer === 0 && rectIntersect(player.x, player.y, player.width, player.height, enemy.x, enemy.y, enemy.w, enemy.h)) {
                if (player.invulnerable <= 0) {
                    player.hp--;
                    player.invulnerable = 60;
                    player.vy = -5;
                    player.vx = player.x < enemy.x ? -10 : 10;
                    updateUI();
                }
            }
        });

        // é£Ÿç‰©
        foods.forEach((food, index) => {
            if (!food.eaten && rectIntersect(player.x, player.y, player.width, player.height, food.x, food.y, food.w, food.h)) {
                food.eaten = true;
                if(player.hp < player.maxHp) { player.hp++; updateUI(); }
                foods.splice(index, 1);
            }
        });

        // 5. éé—œåˆ¤å®š
        if (rectIntersect(player.x, player.y, player.width, player.height, exitDoor.x, exitDoor.y, exitDoor.w, exitDoor.h)) {
            if (isLevelSwitching) return;
            isLevelSwitching = true;

            setTimeout(() => {
                if (currentLevel < 3) {
                    currentLevel++;
                    
                    // *** ä¿®æ”¹ï¼šéé—œæ™‚è£œæ»¿è¡€é‡ ***
                    player.hp = player.maxHp; 
                    updateUI(); 

                    alert(`é€šéç¬¬ ${currentLevel-1} é—œï¼é€²å…¥ç¬¬ ${currentLevel} é—œï¼(ç”Ÿå‘½å€¼å·²è£œæ»¿)`);
                    setupLevel(currentLevel);
                } else {
                    startVictoryAnimation();
                }
            }, 10);
            player.x -= 10; 
        }
        
        if (player.invulnerable > 0) player.invulnerable--;
    }

    function checkPlatformCollision(obj, p) {
        if (obj.x + obj.width > p.x + 5 && 
            obj.x < p.x + p.w - 5 &&
            obj.y + obj.height > p.y &&
            obj.y + obj.height < p.y + p.h + 20 && 
            obj.vy >= 0) {
            
            obj.y = p.y - obj.height;
            obj.vy = 0;
            obj.grounded = true; 
            return;
        }
        if (obj.y + obj.height > p.y + 10 && obj.y < p.y + p.h) {
             if (obj.x + obj.width > p.x && obj.x < p.x + p.w) {
                 if(obj.vx > 0) obj.x = p.x - obj.width;
                 if(obj.vx < 0) obj.x = p.x + p.w;
                 obj.vx = 0;
             }
        }
    }

    function rectIntersect(x1, y1, w1, h1, x2, y2, w2, h2) {
        return x2 < x1 + w1 && x2 + w2 > x1 && y2 < y1 + h1 && y2 + h2 > y1;
    }

    function startVictoryAnimation() {
        if (isGameWon) return; 
        isGameWon = true;
        resetInput(); 
        
        for(let i=0; i<100; i++) {
            particles.push({
                x: LOGICAL_CANVAS_WIDTH/2,
                y: canvas.height/2,
                vx: (Math.random() - 0.5) * 15,
                vy: (Math.random() - 0.5) * 15,
                emoji: ['ğŸ‰', 'âœ¨', 'ğŸ†', 'â­'][Math.floor(Math.random()*4)],
                life: 100 + Math.random() * 100
            });
        }
        restartBtn.style.display = 'block';
    }

    function updateVictoryParticles() {
        particles.forEach(p => {
            p.x += p.vx;
            p.y += p.vy;
            p.vy += 0.1; // é‡åŠ›
            p.life--;
        });
    }

    function drawVictoryScreen() {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.textAlign = 'center';
        ctx.fillStyle = '#FFD700'; 
        ctx.font = 'bold 60px "Microsoft JhengHei"';
        ctx.fillText("æ­å–œéé—œï¼", LOGICAL_CANVAS_WIDTH/2, canvas.height/2 - 20);
        ctx.fillStyle = 'white';
        ctx.font = '24px "Microsoft JhengHei"';
        ctx.fillText("ä½ æ‰“æ•—äº†èŒƒé˜¿å‘†ï¼Œ", LOGICAL_CANVAS_WIDTH/2, canvas.height/2 + 30);
        ctx.fillText("æˆç‚ºäº†çœŸæ­£çš„è‹±é›„ï¼", LOGICAL_CANVAS_WIDTH/2, canvas.height/2 + 60);

        particles.forEach(p => {
            if(p.life > 0) {
                ctx.font = '20px Arial';
                ctx.fillText(p.emoji, p.x, p.y);
            }
        });
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (isGameWon) {
            drawVictoryScreen();
            return;
        }

        ctx.save();
        ctx.translate(-cameraX, 0);

        ctx.font = '80px Arial';
        ctx.fillText(exitDoor.emoji, exitDoor.x, exitDoor.y + exitDoor.h - 10);

        platforms.forEach(p => {
            ctx.fillStyle = '#5D4037'; ctx.fillRect(p.x, p.y, p.w, p.h);
            ctx.fillStyle = '#388E3C'; ctx.fillRect(p.x, p.y, p.w, 8);
        });

        ctx.font = '30px Arial'; ctx.textAlign = 'center';
        foods.forEach(f => ctx.fillText(f.type, f.x + f.w/2, f.y + f.h - 5));

        enemies.forEach(e => {
            ctx.save();
            ctx.translate(e.x + e.w/2, e.y + e.h/2);
            if(e.hurtTimer > 0 && Math.floor(Date.now()/50)%2) ctx.globalAlpha = 0.3;
            if (!e.flying && e.vx > 0) ctx.scale(-1, 1); 
            
            let fontSize = e.isBoss ? (e.name === 'èŒƒé˜¿å‘†' ? 80 : 60) : 30;
            ctx.font = `${fontSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText(e.type, 0, e.isBoss ? 30 : 10);

            if (e.isBoss) {
                ctx.font = 'bold 20px "Microsoft JhengHei"';
                ctx.fillStyle = 'yellow';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 3;
                let nameY = e.name === 'èŒƒé˜¿å‘†' ? -60 : -40;
                ctx.strokeText(e.name, 0, nameY);
                ctx.fillText(e.name, 0, nameY);
                
                let barY = e.name === 'èŒƒé˜¿å‘†' ? -50 : -30;
                ctx.fillStyle = 'red';
                ctx.fillRect(-40, barY, 80, 8);
                ctx.fillStyle = '#0f0';
                ctx.fillRect(-40, barY, 80 * (e.hp/e.maxHp), 8);
            }
            ctx.restore();
        });

        ctx.save();
        ctx.translate(player.x + player.width/2, player.y + player.height/2);
        if (player.invulnerable > 0 && Math.floor(Date.now() / 100) % 2 === 0) ctx.globalAlpha = 0.5;
        if (!player.facingRight) ctx.scale(-1, 1);
        
        ctx.font = '30px Arial';
        if (player.attacking) {
            ctx.fillText('ğŸ¤º', 5, 10); 
            ctx.font = '40px Arial'; ctx.fillText('ğŸ’¨', 40, 5); 
        } else {
            ctx.fillText(player.emoji, 0, 10);
        }
        ctx.restore();
        ctx.restore();
    }

    function updateUI() {
        let hearts = '';
        for(let i=0; i<player.maxHp; i++) hearts += (i < player.hp) ? 'â¤ï¸' : 'ğŸ–¤';
        ui.innerHTML = `HP: ${hearts}`;
    }

    function loop() {
        update();
        draw();
        requestAnimationFrame(loop);
    }

    setupLevel(1);
    updateUI();
    loop();

</script>
</body>
</html>
