<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>Emoji åŠå®¢å†’éšª v8 - æ±ºæˆ°èŒƒé˜¿å‘†</title>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #222;
            color: white;
            font-family: 'Microsoft JhengHei', 'Segoe UI', sans-serif; /* å¼·åˆ¶å¾®è»Ÿæ­£é»‘é«” */
            overflow: hidden;
        }
        #gameContainer {
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        canvas {
            background-color: #87CEEB; /* å¤©ç©ºè— */
            border-radius: 4px;
            display: block;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 20px;
            font-weight: bold;
            color: #333;
            background: rgba(255, 255, 255, 0.7);
            padding: 5px 10px;
            border-radius: 5px;
            pointer-events: none;
        }
        #instructions {
            margin-top: 10px;
            text-align: center;
            color: #aaa;
            font-size: 14px;
        }
    </style>
</head>
<body>

    <div>
        <div id="gameContainer">
            <canvas id="gameCanvas" width="800" height="400"></canvas>
            <div id="ui">HP: â¤ï¸â¤ï¸â¤ï¸â¤ï¸â¤ï¸</div>
        </div>
        <div id="instructions">
            â¬…ï¸ â¡ï¸ ç§»å‹•(æœ‰æ…£æ€§) | ç©ºç™½éµ è·³èº | Z æ”»æ“Š | çµ‚é»ï¼šèŒƒé˜¿å‘†
        </div>
    </div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const ui = document.getElementById('ui');

    // --- éŠæˆ²åƒæ•¸ ---
    const GRAVITY = 0.25;      
    const JUMP_STRENGTH = -10; 
    const ACCELERATION = 0.5; 
    const FRICTION = 0.9;     
    const MAX_SPEED = 8;      

    const ATTACK_DURATION = 40; 
    const WORLD_WIDTH = 3400; // åœ°åœ–å¤ é•·æ‰èƒ½æ”¾ä¸‹ä¸€å †æ€ª
    const CANVAS_WIDTH = canvas.width;

    let cameraX = 0;
    let isGameOver = false;

    const keys = { ArrowRight: false, ArrowLeft: false, Space: false, z: false };

    // --- è§’è‰² ---
    const player = {
        x: 50,
        y: 100, // ç©å®¶ä¹Ÿå¾ç©ºä¸­å‡ºç”Ÿï¼Œæ¯”è¼ƒå®‰å…¨
        width: 40,
        height: 40,
        vx: 0,
        vy: 0,
        hp: 5,
        maxHp: 5,
        grounded: false,
        facingRight: true,
        attacking: false,
        attackTimer: 0,
        invulnerable: 0,
        emoji: 'ğŸ¤º'
    };

    // --- åœ°åœ–å¹³å° ---
    const platforms = [
        { x: 0, y: 350, w: 600, h: 50 },
        { x: 700, y: 280, w: 100, h: 20 },
        { x: 900, y: 220, w: 100, h: 20 },
        { x: 1100, y: 350, w: 600, h: 50 }, 
        // å›°é›£è·³èºå€
        { x: 1800, y: 280, w: 80, h: 20 },
        { x: 2000, y: 200, w: 80, h: 20 },
        { x: 2200, y: 150, w: 80, h: 20 },
        { x: 2400, y: 250, w: 80, h: 20 },
        // Boss æˆ°é¬¥èˆå° (å¾ˆå¤§ä¸€ç‰‡å¹³åœ°)
        { x: 2600, y: 350, w: 800, h: 50 }, 
        { x: 2800, y: 250, w: 50, h: 100 }, // èŒƒé˜¿å‘†å‰é¢çš„æ©é«”
    ];

    const exitDoor = { x: 3200, y: 270, w: 60, h: 80, emoji: 'ğŸšª' };

    // --- æ€ªç‰©é…ç½® (ä¿®æ­£ï¼šæ‰€æœ‰åœ°é¢æ€ªå‡ºç”Ÿåœ¨ Y=200 ç©ºä¸­ï¼Œç¢ºä¿ä¸æœƒå¡åœ°) ---
    // ğŸ‘¾(æ™®é€š), ğŸ(å¿«), ğŸ§Ÿ(æ…¢ç¡¬), ğŸ‘»(é£›), ğŸ‘¹(Boss)
    let enemies = [
        // ç¬¬ä¸€å€
        { x: 400, y: 200, w: 40, h: 40, vx: 2, vy: 0, hp: 1, maxHp: 1, type: 'ğŸ‘¾' },
        { x: 500, y: 200, w: 40, h: 40, vx: 3, vy: 0, hp: 1, maxHp: 1, type: 'ğŸ' },
        
        // ç¬¬äºŒå€ (åœ°é¢æ€ªè¼ƒå¤š)
        { x: 1200, y: 200, w: 40, h: 40, vx: -1, vy: 0, hp: 3, maxHp: 3, type: 'ğŸ§Ÿ' },
        { x: 1400, y: 200, w: 40, h: 40, vx: 1, vy: 0, hp: 3, maxHp: 3, type: 'ğŸ§Ÿ' },
        { x: 1500, y: 200, w: 40, h: 40, vx: 3, vy: 0, hp: 1, maxHp: 1, type: 'ğŸ' },
        { x: 1600, y: 200, w: 40, h: 40, vx: 2, vy: 0, hp: 1, maxHp: 1, type: 'ğŸ‘¾' },

        // ç©ºä¸­éƒ¨éšŠ
        { x: 800, y: 50, w: 40, h: 40, vx: 0, vy: 0, hp: 2, maxHp: 2, type: 'ğŸ‘»', flying: true },
        { x: 1900, y: 50, w: 40, h: 40, vx: 0, vy: 0, hp: 2, maxHp: 2, type: 'ğŸ‘»', flying: true },
        { x: 2300, y: 50, w: 40, h: 40, vx: 0, vy: 0, hp: 2, maxHp: 2, type: 'ğŸ‘»', flying: true },

        // --- Boss èŒƒé˜¿å‘† ---
        { 
            x: 3000, y: 200, // å¾å¤©è€Œé™çš„ç‹è€…
            w: 100, h: 100, // æ›´å¤§éš»
            vx: 0, vy: 0, 
            hp: 15, maxHp: 15, 
            type: 'ğŸ‘¹', 
            isBoss: true, 
            name: "æˆ‘æ˜¯èŒƒé˜¿å‘†"
        }
    ];

    enemies.forEach(e => e.hurtTimer = 0);

    let foods = [
        { x: 930, y: 180, w: 30, h: 30, eaten: false, type: 'ğŸ–' },
        { x: 2100, y: 110, w: 30, h: 30, eaten: false, type: 'ğŸ–' },
        { x: 2700, y: 310, w: 30, h: 30, eaten: false, type: 'ğŸ–' }
    ];

    // æŒ‰éµç›£è½
    window.addEventListener('keydown', (e) => {
        if(e.code === 'Space') keys.Space = true;
        if(e.code === 'ArrowRight') keys.ArrowRight = true;
        if(e.code === 'ArrowLeft') keys.ArrowLeft = true;
        if(e.code === 'KeyZ') { if (!player.attacking) startAttack(); }
    });
    window.addEventListener('keyup', (e) => {
        if(e.code === 'Space') keys.Space = false;
        if(e.code === 'ArrowRight') keys.ArrowRight = false;
        if(e.code === 'ArrowLeft') keys.ArrowLeft = false;
    });

    function startAttack() {
        player.attacking = true;
        player.attackTimer = ATTACK_DURATION;
    }

    // --- éŠæˆ²é‚è¼¯ ---
    function update() {
        if (isGameOver) return; 

        if (player.hp <= 0) {
            endGame("æŒ‘æˆ°å¤±æ•—ï¼æŒ‰ç¢ºå®šé‡æ–°é–‹å§‹");
            return;
        }

        // 1. ç©å®¶ç‰©ç†
        if (keys.ArrowRight) { player.vx += ACCELERATION; player.facingRight = true; }
        if (keys.ArrowLeft) { player.vx -= ACCELERATION; player.facingRight = false; }
        
        player.vx *= FRICTION;
        if (player.vx > MAX_SPEED) player.vx = MAX_SPEED;
        if (player.vx < -MAX_SPEED) player.vx = -MAX_SPEED;
        if (Math.abs(player.vx) < 0.1) player.vx = 0;

        player.x += player.vx;
        player.vy += GRAVITY;
        player.y += player.vy;
        
        if (keys.Space && player.grounded) {
            player.vy = JUMP_STRENGTH;
            player.grounded = false;
        }

        // ç©å®¶ç¢°æ’
        player.grounded = false; 
        platforms.forEach(p => checkPlatformCollision(player, p));

        // é‚Šç•Œ
        if (player.x < 0) { player.x = 0; player.vx = 0; }
        if (player.x + player.width > WORLD_WIDTH) { player.x = WORLD_WIDTH - player.width; player.vx = 0; }
        if (player.y > canvas.height + 200) player.hp = 0; // æ‰è½æ­»äº¡

        // 2. æ”å½±æ©Ÿ
        cameraX = player.x - CANVAS_WIDTH / 2;
        if (cameraX < 0) cameraX = 0;
        if (cameraX > WORLD_WIDTH - CANVAS_WIDTH) cameraX = WORLD_WIDTH - CANVAS_WIDTH;

        // 3. æ”»æ“Š
        if (player.attacking) {
            player.attackTimer--;
            const attackRange = 80; // åŠ å¤§æ”»æ“Šç¯„åœ
            const hitX = player.facingRight ? player.x + player.width : player.x - attackRange;
            
            for (let i = enemies.length - 1; i >= 0; i--) {
                let enemy = enemies[i];
                if (enemy.hurtTimer > 0) continue;

                if (rectIntersect(hitX, player.y, attackRange, player.height, enemy.x, enemy.y, enemy.w, enemy.h)) {
                    enemy.hp--;
                    enemy.hurtTimer = 15;
                    // æ“Šé€€
                    let kX = enemy.isBoss ? 2 : 8;
                    let kY = enemy.isBoss ? -2 : -5;
                    enemy.vx = (enemy.x > player.x) ? kX : -kX;
                    enemy.vy = kY;

                    if (enemy.hp <= 0) enemies.splice(i, 1);
                }
            }
            if (player.attackTimer <= 0) player.attacking = false;
        }

        // 4. æ€ªç‰©é‚è¼¯
        enemies.forEach(enemy => {
            if (enemy.hurtTimer > 0) {
                enemy.hurtTimer--;
                enemy.vy += GRAVITY;
                enemy.vx *= 0.9;
            } else {
                // AI è¡Œç‚º
                if (enemy.flying) {
                    // é¬¼é­‚è¿½è¹¤
                    const dx = player.x - enemy.x;
                    const dy = player.y - enemy.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < 600) {
                        enemy.vx = (dx / dist) * 1.5;
                        enemy.vy = (dy / dist) * 1.5;
                    } else {
                        enemy.vx = 0; enemy.vy = 0;
                    }
                } else {
                    // åœ°é¢æ€ªç‰©
                    if (enemy.isBoss) {
                        // Boss é‚è¼¯: ç©å®¶é è¿‘æ™‚æ‰ç§»å‹•
                        if (Math.abs(player.x - enemy.x) < 500) {
                            let speed = 1.0;
                            enemy.vx = player.x > enemy.x ? speed : -speed;
                        } else {
                            enemy.vx = 0;
                        }
                    } else {
                        // ä¸€èˆ¬æ€ªå·¡é‚
                        let speed = (enemy.type === 'ğŸ') ? 4 : (enemy.type === 'ğŸ§Ÿ' ? 0.5 : 2);
                        if (Math.abs(enemy.vx) < 0.1) enemy.vx = speed; // ç¢ºä¿æœ‰åˆé€Ÿ
                        if (enemy.vx > 0) enemy.vx = speed; else enemy.vx = -speed;
                    }
                    enemy.vy += GRAVITY;
                }
            }

            enemy.x += enemy.vx;
            enemy.y += enemy.vy;

            // æ€ªç‰©ç¢°æ’åœ°å½¢
            let enemyGrounded = false;
            if (!enemy.flying) {
                platforms.forEach(p => {
                    // ä½¿ç”¨ç°¡åŒ–ç‰ˆçš„ç¢°æ’çµ¦æ€ªç‰©ï¼Œé¿å…å¡ç‰†
                    if (enemy.x + enemy.w > p.x && enemy.x < p.x + p.w &&
                        enemy.y + enemy.h > p.y && enemy.y + enemy.h < p.y + p.h + 10 &&
                        enemy.vy >= 0) {
                        
                        enemy.y = p.y - enemy.h;
                        enemy.vy = 0;
                        enemyGrounded = true;
                    }
                });
            }

            // æ‡¸å´–å‹’é¦¬ (ä¿®æ­£ï¼šä½¿ç”¨å®¹éŒ¯åˆ¤å®š)
            if (!enemy.flying && enemyGrounded && enemy.hurtTimer === 0 && !enemy.isBoss) {
                let checkX = enemy.x + (enemy.vx > 0 ? enemy.w + 10 : -10);
                let groundAhead = false;
                
                platforms.forEach(p => {
                    // åªè¦æª¢æŸ¥é»åœ¨å¹³å° X ç¯„åœå…§ï¼Œä¸”å¹³å° Y æ¥è¿‘æ€ªç‰©è…³ä¸‹
                    if (checkX > p.x && checkX < p.x + p.w && Math.abs((enemy.y + enemy.h) - p.y) < 5) {
                        groundAhead = true;
                    }
                });

                if (!groundAhead || enemy.x <= 0 || enemy.x + enemy.w >= WORLD_WIDTH) {
                    enemy.vx *= -1; // å›é ­
                }
            }
            
            // Boss å¼·åˆ¶é‚Šç•Œ (é˜²æ­¢ Boss æ‰ä¸‹å»)
            if (enemy.isBoss && enemy.y > canvas.height) {
                enemy.y = 200; // æ‰ä¸‹å»å°±å‚³é€å›ä¾†
                enemy.vy = 0;
            }

            // å‚·å®³åˆ¤å®š
            if (enemy.hurtTimer === 0 && rectIntersect(player.x, player.y, player.width, player.height, enemy.x, enemy.y, enemy.w, enemy.h)) {
                if (player.invulnerable <= 0) {
                    player.hp--;
                    player.invulnerable = 60;
                    player.vy = -5;
                    player.vx = player.x < enemy.x ? -10 : 10;
                    updateUI();
                }
            }
        });

        // é£Ÿç‰©
        foods.forEach((food, index) => {
            if (!food.eaten && rectIntersect(player.x, player.y, player.width, player.height, food.x, food.y, food.w, food.h)) {
                food.eaten = true;
                if(player.hp < player.maxHp) { player.hp++; updateUI(); }
                foods.splice(index, 1);
            }
        });

        // å‹åˆ©
        if (rectIntersect(player.x, player.y, player.width, player.height, exitDoor.x, exitDoor.y, exitDoor.w, exitDoor.h)) {
            endGame("æ­å–œï¼ä½ æ‰“æ•—äº†èŒƒé˜¿å‘†ï¼ˆæˆ–ç¹éäº†ä»–ï¼‰ï¼ŒæˆåŠŸéé—œï¼ğŸ‰");
        }
        
        if (player.invulnerable > 0) player.invulnerable--;
    }

    // ç©å®¶å°ˆç”¨çš„ç¢°æ’æª¢æ¸¬ (åŒ…å«å´å‘é˜»æ“‹)
    function checkPlatformCollision(obj, p) {
        // è…³åº•ç¢°æ’
        if (obj.x + obj.width > p.x + 5 && 
            obj.x < p.x + p.w - 5 &&
            obj.y + obj.height > p.y &&
            obj.y + obj.height < p.y + p.h + 20 && 
            obj.vy >= 0) {
            
            obj.y = p.y - obj.height;
            obj.vy = 0;
            obj.grounded = true; 
            return;
        }
        // å´å‘ç¢°æ’ (åªå°ç©å®¶ç”Ÿæ•ˆ)
        if (obj.y + obj.height > p.y + 10 && obj.y < p.y + p.h) {
             if (obj.x + obj.width > p.x && obj.x < p.x + p.w) {
                 if(obj.vx > 0) obj.x = p.x - obj.width;
                 if(obj.vx < 0) obj.x = p.x + p.w;
                 obj.vx = 0;
             }
        }
    }

    function rectIntersect(x1, y1, w1, h1, x2, y2, w2, h2) {
        return x2 < x1 + w1 && x2 + w2 > x1 && y2 < y1 + h1 && y2 + h2 > y1;
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.save();
        ctx.translate(-cameraX, 0);

        // é–€
        ctx.font = '80px Arial';
        ctx.fillText(exitDoor.emoji, exitDoor.x, exitDoor.y + exitDoor.h - 10);

        // å¹³å°
        platforms.forEach(p => {
            ctx.fillStyle = '#5D4037'; ctx.fillRect(p.x, p.y, p.w, p.h);
            ctx.fillStyle = '#388E3C'; ctx.fillRect(p.x, p.y, p.w, 8);
        });

        // é£Ÿç‰©
        ctx.font = '30px Arial'; ctx.textAlign = 'center';
        foods.forEach(f => ctx.fillText(f.type, f.x + f.w/2, f.y + f.h - 5));

        // æ€ªç‰©
        enemies.forEach(e => {
            ctx.save();
            ctx.translate(e.x + e.w/2, e.y + e.h/2);
            if(e.hurtTimer > 0 && Math.floor(Date.now()/50)%2) ctx.globalAlpha = 0.3;
            if (!e.flying && e.vx > 0) ctx.scale(-1, 1); 
            
            let fontSize = e.isBoss ? 80 : 30;
            ctx.font = `${fontSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText(e.type, 0, e.isBoss ? 30 : 10);

            // Boss åå­—
            if (e.isBoss) {
                ctx.font = 'bold 24px "Microsoft JhengHei"';
                ctx.fillStyle = 'yellow';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 3;
                ctx.strokeText(e.name, 0, -60);
                ctx.fillText(e.name, 0, -60);
                
                // Boss è¡€æ¢
                ctx.fillStyle = 'red';
                ctx.fillRect(-50, -50, 100, 10);
                ctx.fillStyle = '#0f0';
                ctx.fillRect(-50, -50, 100 * (e.hp/e.maxHp), 10);
            }
            ctx.restore();
        });

        // ç©å®¶
        ctx.save();
        ctx.translate(player.x + player.width/2, player.y + player.height/2);
        if (player.invulnerable > 0 && Math.floor(Date.now() / 100) % 2 === 0) ctx.globalAlpha = 0.5;
        if (!player.facingRight) ctx.scale(-1, 1);
        
        ctx.font = '30px Arial';
        if (player.attacking) {
            ctx.fillText('ğŸ¤º', 5, 10); 
            ctx.font = '40px Arial'; ctx.fillText('ğŸ’¨', 40, 5); 
        } else {
            ctx.fillText(player.emoji, 0, 10);
        }
        ctx.restore();
        ctx.restore();
    }

    function updateUI() {
        let hearts = '';
        for(let i=0; i<player.maxHp; i++) hearts += (i < player.hp) ? 'â¤ï¸' : 'ğŸ–¤';
        ui.innerHTML = `HP: ${hearts}`;
    }

    function endGame(msg) {
        if (isGameOver) return; 
        isGameOver = true;
        setTimeout(() => { alert(msg); location.reload(); }, 50);
    }

    function loop() {
        update();
        draw();
        requestAnimationFrame(loop);
    }

    updateUI();
    loop();

</script>
</body>
</html>